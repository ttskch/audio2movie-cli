#!/usr/bin/env php
<?php
require_once __DIR__ . '/vendor/autoload.php';

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Exception\ProcessFailedException;
use Symfony\Component\Process\Process;

class MyCommand extends Command
{
    protected function configure()
    {
        $this
            ->setName('conv')
            ->setDescription('Convert audio file to simple video file')
            ->addArgument('audio-file', InputArgument::REQUIRED, 'path to audio file')
            ->addOption('output-format', 'o', InputOption::VALUE_REQUIRED, 'defaults to "mp4"')
            ->addOption('image-file', 'i', InputOption::VALUE_REQUIRED, 'path to image file')
            ->addOption('image-color', 'c', InputOption::VALUE_REQUIRED, 'if "--image_file" isn\'t set, you can specify the color of auto-generated simple color image. defaults to "black"')
            ->addOption('image-resolution', 'r', InputOption::VALUE_REQUIRED, 'if "--image_file" isn\'t set, you can specify the resolution of auto-generated simple color image. defaults to "800x450"')
            ->addOption('frame-rate', 'f', InputOption::VALUE_REQUIRED, 'defaults to 30')
            ->addOption('overwrite', 'w', InputOption::VALUE_NONE, 'if you set this flag, existing video file which has output target filename will be overwritten')
        ;
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $audioFilePath = $input->getArgument('audio-file');
        $outputFormat = $input->getOption('output-format') ?: 'mp4';
        $imageFilePath = $input->getOption('image-file');
        $imageColor = $input->getOption('image-color') ?: 'black';
        $imageResolution = $input->getOption('image-resolution') ?: '800x450';
        $frameRate = intval($input->getOption('frame-rate')) ?: 30;
        $overwrite = boolval($input->getOption('overwrite'));

        $tmpDirPath = sprintf('%s_%s', sys_get_temp_dir().'/audio2video', preg_replace('/[.\s]/', '', microtime()));
        mkdir($tmpDirPath);

        // get the duration of the input audio.
        $process = new Process("ffprobe -show_streams -print_format json '{$audioFilePath}' 2>/dev/null");
        $process->setTimeout(300);
        $process->run();
        $this->ensureSuccessful($process);
        $duration = floatval(json_decode($process->getOutput())->streams[0]->duration);

        // get the required number of images.
        $frameNum = intval(ceil($duration * $frameRate));

        // place uploaded image or new-created image as origin of copies.
        if ($imageFilePath) {
            $imageExt = pathinfo($imageFilePath, PATHINFO_EXTENSION);
            copy($imageFilePath, $tmpDirPath."/origin.{$imageExt}");
        } else {
            // create blank image.
            $image = new \Imagick();
            list($w, $h) = explode('x', $imageResolution);
            $image->newImage($w, $h, $imageColor, 'jpg');
            $image->writeImage($tmpDirPath.'/origin.jpg');
            $imageExt = 'jpg';
        }

        // generate sequential numbered images.
        for ($i = 0; $i < $frameNum; $i++) {
            copy($tmpDirPath."/origin.{$imageExt}", sprintf('%s/%06d.%s', $tmpDirPath, $i, $imageExt));
        }

        // generate video file.
        $outputFilePath = preg_replace('/([^.]+)$/', $outputFormat, $audioFilePath);
        $y = $overwrite ? '-y' : '';
        $process = new Process("ffmpeg {$y} -r {$frameRate} -i '{$tmpDirPath}/%06d.{$imageExt}' -i '{$audioFilePath}' -r 30 -vcodec libx264 -pix_fmt yuv420p '{$outputFilePath}'");
        $process->setTimeout(300);
        $process->run();
        $this->ensureSuccessful($process);

        $output->writeln("{$outputFilePath} is generated successfully.");
    }

    private function ensureSuccessful(Process $process)
    {
        if (!$process->isSuccessful()) {
            throw new ProcessFailedException($process);
        }
    }
}

$console = new Application();
$console->add(new MyCommand());
$console->run();
